## Отзыв на архитектуру и не только

**Авторы:** Лочмелис Денис, Соловьев Глеб

Нашей задачей было реализовать команды `cd` и `ls`, а также поддержать смену текущей директории в других командах (`cat`
, `wc` и другие). Изложим наши юношеские чувства, возникшие в проекте прекрасных девушек. А также поделимся несколькими
замечаниями по возможному улучшению проекта.

### Что было удобным

Безусловно, само по себе **добавление новых команд**. В проекте есть достаточно непростые для понимания внутренней
реализации классы (такие, как `Executor` или `CommandParser`, например) &mdash; но с ними не пришлось детально
разбираться, чтобы добавить `cd` и `ls`. Более того, даже регистрация новых команд в приложении произошла автоматически,
благодаря использованному девушками `java.lang.reflect`. Наконец, все классы команд были собраны в отдельный пакет
&mdash; что тоже было удобно при разработке: было легче изучать примеры уже реализованных команд.

Кроме того, в `README.md` можно было найти **описание основных компонент** приложения и схему их взаимодействия, отчего
уверенность при изменении реализации уже написанного кода (чтобы поддержать новый функционал в старых командах) была
больше.

### Что показалось неудобным :(

Опишем в порядке от меньших зол к большим &mdash; восприимчивый читатель сможет вовремя остановиться.

### Git: как отыскать истину?

Для добавления новых команд и новой функциональности было необходимо сперва выбрать существующую ветку в проекте, от
которой создавать новую. С этими были трудности: неконсистентные названия веток и сообщений в коммитах, опечатки (ну дай
Бог с этим всем), **несинхронизированные изменения между ветками** с нелинейной историей. Например, между `hw3-shell`
и `grep` происходили слияния; при этом часть свежих исправлений старого (относительно `grep`) функционала в `hw3-shell`
не была добавлена в непосредственно `grep`, отчего использовать его казалось небезопасным (коммиты `Fix parser...`
, `Fix quotes with spaces...` и т. д.).

*Итого:* потратили время на то, чтобы разобраться, какую ветку безопаснее использовать. См. раздел `Тесты` &mdash;
потребовалось также перебирать и коммиты.

### Качество кода: предупреждаем о недоверии

Мы уверены, что оригинальная команда проекта работала в `IntelliJ IDEA` (или в какой-то другой мощной среде разработки
на Java) &mdash; однако при работе с кодом проекта мы столкнулись **с большим количеством warning-ов**,
подсвечиваемых `IntelliJ IDEA`, чаще всего оправданных. Например, неиспользуемые переменные, отсутствие `final`
модификаторов, ненужные импорты и т. д.

К качеству кода также есть замечание с точки зрения Java: жутко неудобным было повсеместное использование `ArrayList`-ов 
вместо `List`-ов в проекте. Кроме идеологических проблем это повлекло за собой необходимость оборачивать конструкции 
вроде `List.of` в конструктор `ArrayList`-а повсеместно в тестах. Это вызвало очень неприятный рост количества 
бессмысленного кода.

Также проблемы были и с документацией: например, недописанная фраза `Args should be.` в `CommandEcho`; исключение без
объяснения причины `@throws MyShellException` в `LoggerWithHandler` и т. д. Наконец, **отсутствие консистентности** &mdash;
если в `CommandExternal` у конструктора есть подробная документация, а документация методов `validate...` ссылается
на `AbstractCommand`; то у других команд конструкторы оставлены без документации, в отличие от методов `validate...`.

Вопрос отсутствия консистентности также касается и логов об ошибках: в `CommandCat` и `CommandAssignment` они написаны в
разных стилях. Вдобавок, консистентность стиля кода трудно поддерживать автоматически &mdash; в проекте
отсутствует `.editorconfig`, отсутствуют линтеры.

*Итого:* по отдельности данные замечания несильно заметны, однако вместе они порождают две проблемы. Первая &mdash;
**плохое понимание стиля кода** в проекте и, следовательно, трудности с его добавлением сторонними разработчиками 
(хочется сделать консистентно для читаемости, но консистентности нет исходно, правила не заданы).
Вторая &mdash; **недоверие к коду**, вызванное большим количеством warning-ов, опечаток и т. д.

### README.md: вопросы без ответов

Есть проблемы с оформлением: например, опечатки.

Более существенны **неточности в диаграмме классов** (мы смотрели на более свежую, `UML`-версию в ветке `grep`).
Например, `Preprocessor` используется `MyShell`-ом, а не `Executor`-ом, как это показано на схеме. Потом, реализации
интерфейса `AbstractCommand` имеют неожиданно разный тип полей: одни &mdash;`ArrayList<String>`, другие
&mdash; `ArrayList<File>`. Неожиданным он является, так как методы интерфейса принимают именно первый
тип (`ArrayList<String>`), а не второй. И самое главное, нигде в архитектурной документации объяснения подобного
различия мы не нашли. Наконец, проблемы с оформлением: обрезанные типы в интерфейсе `AbstractCommand`, явно неудачное
обозначение компонент на схеме (которое коллизится с линиями связей).

Самым же неудачным в *архитектурной* документации нам показалось **отсутствие описания мотивации принятых решений**.
Почему `Environment` реализован как синглтон? Почему реализации `AbstractCommand` имеют разные типы полей? Почему было
принято решение разделить динамические и статические аргументы? Почему, в конце концов, динамические аргументы имеют тип
списка (см. подробнее далее)? Ответов на данные вопросы очень не хватало, эти вопросы становились важными во
время разработки. В результате чего, при добавлении новой функциональности было невозможно понять логику авторов и
ей следовать.

### Тесты: падают, как и доверие к коду

Самое плохое в тестах, когда они **исходно уже не проходят** :( При запуске на локальной `ubuntu` тесты, начиная с
коммита `d90091c` (`Add tests`) в ветке `hw3-shell`, полностью не проходили. Как выяснилось при детальном исследовании
&mdash; локально на машине не было файла `/bin/wc`, который требовался в тесте. Проблема понятная (и в CI ее не
возникало), однако при написании тестов с вызовом внешних команд однозначно стоит поддерживать возможность их отсутствия.

В результате обозначенной выше проблемы нам пришлось искать самый свежий коммит в `hw3-shell` с проходящими тестами и
создавать новую ветку именно от него. Было неудобно :(

Также хочется сделать замечание про **тесты для Windows** &mdash; **в CI их не было**. И не случайно, на `Windows`
машине одного из участников нашей команды падало порядка 6 тестов. Большинство, кажется, из-за ненайденной той или иной
внешней команды, но не все. Таким образом, с этим было неприятно столкнуться в проекте, одним из требований которого
была кроссплатформенность.

Кроме того, в контексте описанных в разделах выше проблем и обсуждений в пул-реквестах, к корректности программы
сложилось недоверие. Безусловно, какой-нибудь **инструмент для измерения покрытия тестами** (например,
[jacoco](https://www.baeldung.com/jacoco)) мог бы развеять сомнения и в принципе на постоянной основе помогать
разработчикам находить непокрытые тестами ветви исполнения программы.

К причинам недоверия к корректности также можно отнести **отсутствие интеграционных тестов** на `MyShell`. Как
следствие, при тестировании нового функционала возникали сомнения, где искать ошибку &mdash; в новом коде или в старом.

Увы, не первой причиной сомнений послужили странные комментарии в коде: `//important test`. Если бывают важные и неважные
тесты, то в чем их разница? Допускают ли авторы падение последних? Возможно, стоило описать это в документах проекта или
обозначить особенности тестов с помощью непосредственно кода.

Самое последнее по поводу тестов в целом &mdash; их **декомпозиция по файлам**. Тестируемых классов порядка 13, в то
время как файлов с тестами &mdash; 3 штуки. По объемным файлам (`CommandsTest` порядка 500 строк) сложнее
навигироваться; при падении же теста больше времени занимает осознание ответственного за проблему класса.

### Архитектура: Environment и опасный синглтон

Про плюсы и особенно минусы использования синглтонов есть много обсуждений, например, можно почитать
на [Stackoverflow](https://stackoverflow.com/questions/137975/what-are-drawbacks-or-disadvantages-of-singleton-pattern?page=1&tab=scoredesc#tab-top).
Нас они коснулись при написании тестов (по ссылке есть пункт про тестируемость) &mdash; тестировать приложение с
глобальным состоянием сложно. Во-первых, подобный класс не подменить на класс-заглушку. Во-вторых, появляется состояние
между тестами, что может стать причиной их падения &mdash; с чем мы столкнулись при тестировании `cd` и `ls`. Конечно,
данная проблема проявилась после того, как мы добавили еще больше состояния в `Environment` (добавили текущий путь
помимо хеш-таблицы с переменными окружения), и, к счастью, нам удалось ее быстро разрешить (очищением `Environment`
в `@BeforeEach`). Однако, безусловно, заложенной бомбой стало **использование синглтона в исходном проекте**.

Конечно, подобного рода решение может быть оправдано. Но в таком случае полезно описывать причины и предостережения в
*архитектурной* документации. Наконец, позаботиться о проблемах принятого решения заранее &mdash; например, форсировать
очистку глобального состояния во всех тестах. Благо, используется достаточно мощный фреймворк.

### Архитектура: MyShell и болезненное тестирование

Интеграционных тестов в оригинальном проекте не было &mdash; поэтому их пришлось писать нам. Проблемы было
две.

*Комментарий:* интеграционные тесты нам были необходимы, так как реакцию внутренних команд на смену текущей директории
можно было проверить только в связке с `cd`.

Первая &mdash; **реализация логики** `MyShell` **внутри метода** `main`: так как единственным способом выйти из Java-программы с
заданным кодом возврата является `System.exit`, то именно он и был использован в завершении логики `MyShell`-а. По этой
причине тестировать `MyShell`, вызывая `main`, было невозможно &mdash; `System.exit` завершал весь процесс с тестом,
фреймворк не получал результат, тест игнорировался. В качестве решения мы выделили логику `MyShell`-а в его метод `run`,
непосредственно который вызывался в `main`, завершаясь `System.exit`-ом.<br/>
*Итого:* однозначная проблема оригинального кода, которую нам пришлось решать.

Вторая &mdash; **логика отображения, смешанная с основной логикой** `MyShell`-а. А именно, `MyShell` в тот же поток, в
который печатается вывод команд (`System.out`), печатал элементы интерфейса пользователя: `Staring MyShell...`, `>> `.
Из-за этого писать интеграционные тесты на логику приложения было намного неудобнее &mdash; необходимо было соблюсти
правильный вывод элементов; более того, в принципе каждый раз элементы выписывая (ухудшая читаемость тестов). К проблемам с
тестированием отображения можно отнести и подмену системных потоков, которую приходилось делать. Это менее критично,
однако с нашей точки зрения было бы гораздо правильнее вынести взаимодействие с пользователем в отдельную сущность 
(какой-нибудь класс `View`), который было бы достаточно протестировать ровно один раз, после чего в интеграционных
тестах `MyShell`-а подменять сущность на фиктивную.

### Архитектура: AbstractCommand и бесконечное скрытое "было бы лучше, если"

Наконец, перейдем к архитектурным решениям относительно `AbstractCommand`, которые сильнее всего заставили нас 
недоумевать.

1. В наследниках `AbstractCommand` создателями `MyShell`-a подразумевается **нигде не обозначенный инвариант**: методы 
`validateStaticArgs` и `validateDynamicArgs` должны вызываться вместе в конструкторе соответствующего класса и сохранять
переданные аргументы в поля класса. О существовании данного инварианта мы узнали исключительно на примерах уже 
написанных команд &mdash; все остальное было против нас и лишь скрывало инвариант.
 * Оба методы &mdash; публичные. Поэтому было подозрение, что их кто-то должен вызывать снаружи. Однако, как выяснилось, 
   это было заблуждение. В коде девушек они вызываются *только в конструкторах соответствующих наследников*.
 * В документации к методам написано: `save if correct`. Это лишь вводило в заблуждение. `Executor` вызовет данные
   методы и через них передаст аргументы команде? Или данные методы должны вызываться в конструкторе? 
   В методе `execute`? Сколько раз вообще наследник `AbstractCommand` может получить свои аргументы: в конструкторе, 
   в `validate...`? Что должно происходить с сохранением аргументов, если `if correct` неверно?
 * Документации к `validateDynamicArgs` в отдельности не было &mdash; от этого метод становился только таинственнее, 
   как и его взаимоотношения с `validateStaticArgs`.
 * Методы `validate...` зовутся в конструкторах, даже если не имеют реализации &mdash; закрадываются подозрения, 
   что если так не делать, может что-то сломаться. Они, как выяснилось, ложные.
 * Названия методов `validate...` подразумевают валидацию аргументов &mdash; но никак не их сохранение, чем обычно 
   занимается конструктор.
 * В `README.md` про данные методы было написано лишь следующее: `валидация аргументов — проверяет корректность аргументов`.
   Не помогло.
 * В том же документе при описании `AbstractCommand` мы встретили следующее: `Поля: статические и динамические аргументы
   (2 массива строк, в каждой конкретной команде будем кастовать к нужным типам), logger, exit code`. 
   А выше: `Абстрактный класс`. Разгадка.

Авторы в архитектурной документации написали про поля и абстрактный класс. В коде использовали интерфейс. Произошло принятие 
архитектурного решения, которое оказалось нигде не описано. В данном случае, безусловно, *необходимым* решением было
сделать `AbstractCommand` заявленным абстрактным классом с заявленными полями; с конструктором, который вызывал бы оба
метода `validate...`, а также инициализировал бы `logger`, который сейчас совершенно одинаково инициализирует каждый
наследник сам. Таким образом, получилось бы явно описать и гарантировать инвариант методов `validate...`.

У нас есть гипотеза, почему оригинальная команда проекта реализовала интерфейс вместо абстрактного класса &mdash; 
если в базовом классе отсутствуют поля конкретных типов (для аргументов команды), то в каждом наследники, т. е. в каждой 
команде, можно хранить аргументы именно в том типе, в котором с ними удобнее работать в `execute`. Например, `CommandCat`: в 
конструкторе он получает `ArrayList<String>`, после чего методы `validate...` собирают из строк списки файлов и сохраняют 
их в поля типов `ArrayList<File>`. Но подобная гибкость, которая дает очень спорный выигрыш (если борьба идет за 
хранение меньшего числа полей, то аргументы в команде вообще можно не хранить, передавая их сразу в `execute`), 
несопоставима **со скрытыми инвариантами**, растекающимися по большому числу классов, и **принципиально неправильным 
использованием Java-интерфейса** (который должен предоставлять *наружу* публичный функционал, скрывая реализацию, но ни 
в коем случае не предоставлять доступ к той самой реализации, внутренним методам `validate...`).

2. Методы `validateStaticArgs` и `validateDynamicArgs` при данном использовании **не должны быть раздельны**. 
Они *всегда* вызываются вместе; более того, даже 
логически валидация статических и динамических аргументов &mdash; это две части единого целого, авторы не приводят 
объяснений, где потребовалось бы их разделять. Кроме того, вся идея валидации аргументов отдельно от `execute` крайне 
сомнительна: в начале де-факто каждого `execute` идет проверка `exitCode`, сохраненного в методах `validate...` => 
таким образом, метод `execute` "знает" про методы `validate...`, связь сохраняется. В связи с этим было бы логичнее 
вызывать метод(ы) валидации аргументов в начале `execute` &mdash; все равно приходится писать `if` и растягивать логику 
валидации на четыре метода.<br/><br/>

3. Тип `ArrayList<String>` в `Result` и смежный `ArrayList<String>` в качестве типа для динамических аргументов &mdash; **опасные рудименты**.
* *Рудименты.* Нигде в коде, нигде в документации нет ответа на вопрос "зачем?". Зачем и почему используются именно 
  списки? В реальности значения либо нет, либо им является единственный `String` &mdash; это классический `Optional`. 
* Более того, даже для хранения ровно одного аргумента команды в поле (после валидации) используются списки. Объяснения 
  этому еще меньше. 
* *Опасные* рудименты &mdash; они очень сильно затрудняют понимание кода и схемы работы программы. Первое наше 
  предположение: наверное, список строк &mdash; это список линий, разделенных переносами строки (мы пытались объяснить список хоть как-то).
  На примерах реализованных команд мы поняли, что это не так: всегда возвращалась одна строка. Ни документация, ни код в итоге не 
  позволили нам понять смысла списка динамических аргументов.
* Наконец, они еще и очень неприятные. Весь код (от реализаций до тестов) увешан бессмысленным оборачиванием строк в списки.

### Итого

Безусловно, базовые архитектурные решения были приняты так, что добавление новых команд &mdash; глобально удобно. 
Но это удобство ощутилось только на уровне создания файлов. Было бы лучше, если бы оно также присутствовало и в процессах реализации, тестирования, и при работе с проектом.

Желаем вам, чтобы в будущих проектах вы больше думали о тестируемости при разработке архитектуры, а также использовали 
все средства Java и сред разработок на максимум. Наконец, может, вообще перешли на более лаконичный Kotlin... 
(на правах рекламы) 